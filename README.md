## Overview
This is my first foray into creating a GUI using python by calculating and plotting the Mandelbrot set. The GUI was manually coded (i.e. without designer) using PyQt6 for basic widgets and PyQtGraph for displaying images. 

The image is displayed as a bitmap that has been transformed from x- and y-pixels to the x- and y-values of the Mandelbrot set. This allows the user to zoom in and out of that static image; when a new image is requested, the x- and y-ranges on the display are used as the ranges for the next image. New images can be generated by pressing the "Plot Mandelbrot" button, entering a number into the "New max iter" textbox and hitting the enter key, or double clicking anywhere on the image.

<img src="https://github.com/SphericalCowPhysics/PyQtGUI-Mandelbrot/assets/151673732/a6baa6f4-bf04-4fe9-b9a6-8fa7c6d15e52" width="900" height="500">

The gif above uses a custom colormap where points that blow up after 33% or less of max iteration are colored red, between 33% and 66% are green, and above 66% are blue. I have also edited out most the downtime waiting for images to generate. Unfortunately, compression has rendered the text illegible. This next gif makes the text legible but does not show off the zooming capabilities of the GUI, so some of the transitions are jarring.
![slowGif](https://github.com/user-attachments/assets/9458dea1-a7d9-40fe-9cb3-542b39688ed2)

Both of these gifs were created using a slightly older version of my GUI that required dozens of seconds to create most images or even minutes as the user zooms further in. This is because generating images with high max iterations is very costly time-wise, but such high max iterations are required to visualize anything interesting deeper in the fractal. My most recent version of the GUI does all the math using Numba, which on average reduces the computation time by 30 times, allowing for much deeper exploration of the Mandelbrot set in a fraction of the time. 

## Widgets
There are five widgets in a column on the left and one image widget on the right.
* Plot Button: when pressed this button emits a signal that triggers the Mandelbrot set to be calculated and displayed using the current max iterations displayed in the graph's sub-title.
* Status Label: displays one of four states. 
	* "Waiting..." when application is initialized.
	* "Calculating..." when application is calculating $z_{n+1}=z_{n}^2 + c.$
	* "Plotting..." when application is applying the array calculated using bitmapping.
	* "Done!" when application has displayed and transformed image.
* Timing Labels: displays the time required for the application to run the current calculation (in seconds) and to apply the bitmap (in milliseconds).
* Max Iteration Textbox: when a new iteration value is typed and enter key is pressed, the variable max_iter gets updated to this new value and the set is calculated and displayed.
* Image: the image is set to 1536x1024 pixels (3:2 aspect ratio) plus room for title, axes and colorbar. The colorbar can be right-clicked to set a new color map or left-clicked and dragged to scale color values. Zooming in or out will change the x- and y-range, which will be used as the range for the next calculated section of the Mandelbrot set. 
![colormaps](https://github.com/user-attachments/assets/e747f957-c17b-4744-a6a5-e5beafd1f8aa)


## Implementing Numba
Numba turns python code into optimized machine code at run time, but unfortunately it is very picky about what code it can run. If it encounters any code that isn't from native python or the NumPy library, it will fail to compile. Naturally, this includes the entirety of the PyQt library. So I simply created a python module called MandelbrotExternalGenerator that generates Mandelbrot data points and images from those data points, and imported the module into my GUI. In order to test the time saved, I created a code that generates a Mandelbrot image once with and once without Numba and compares the time saved. The code repeats a set number of times and increases the max iterations by 500 after each trial. According to the results of my speed test below, Numba causes the code to execute nearly 30x faster.
![numba_speedup_30x](https://github.com/user-attachments/assets/11427451-0950-4a2f-b355-017c2b79a550)


## Known Issues & Unimplemented Features
1. The status label is not updating correctly.  "Calculating..." and "Plotting..." never get displayed. The latter makes sense because on average it is only displayed for about 1 ms before "Done!" is displayed. But why the former is not appearing is unknown. Adding a time-wasting loop between updating label and running calculations did not fix the bug. Current work-around is simply to print these messages to the console.
2. A previous version of the GUI using scatter plots maintained earlier images rather than overwriting them. This way the user could zoom back out to previous images, or pre-generate a wide and deep section of the set and zoom in and out without any new computations. Bitmaps are much faster than scatter plots, but it would be nice to restore this functionality. Could easily save the last couple numpy array images, and have some widget to swap between the images rapidly without recalculating the fractal.
3. ~~While the time to plot the image is negligible (around 1 ms), the time to calculate the values for the image takes at least 30 seconds and quickly scales into minutes as the user zooms in or increases the maximum iterations. This inefficiency is due to python being an interpreted language. Calculations using numba can speed up calculation by approx 30x, however, numba cannot handle native python let alone PyQt. It would be possible to perform calculations externally in numba and send the results to the GUI to be displayed.~~ Implemented this change.
[Image numba_speedup_30x]

